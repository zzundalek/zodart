// Ignore for the schema definition
// ignore_for_file: specify_nonobvious_property_types, avoid_print

import 'package:zodart/zodart.dart';

import 'types.dart';

part 'code_gen_class_example.zodart.dart';

/// Define the id schema to be reused in other schemas.
final id = ZString().trim().toInt().min(1).max(9999);

/// Customer schema with [zodart] annotation
///
/// Reuses the [id] schema.
/// Generate helper class [_$ZCustomerSchemaUtils]
@zodart
abstract class CustomerSchema {
  static final schema = (
    id: id,
    firstName: ZString().trim().min(1).max(20),
    lastName: ZString().trim().min(1).max(20),
  );

  static const z = _$ZCustomerSchemaUtils();

  /// Use autogenerated [ZObject] with default mapper to [Customer].
  static ZObject<Customer> get zObject => z.zObject;
}

/// Item schema with [zodart] annotation
///
/// Reuses the [id] schema.
/// Generate helper class [_$ZItemSchemaUtils]
@zodart
abstract class ItemSchema {
  static final schema = (
    id: id,
    name: ZString().trim().min(1).max(40),
    price: ZDouble().min(0),
  );

  static const z = _$ZItemSchemaUtils();

  /// Use autogenerated [ZObject] with default mapper to [Item].
  static ZObject<Item> get zObject => z.zObject;
}

/// Order schema with [zodart] annotation
///
/// Reuses the [id] schema.
/// Generate helper class [_$ZOrderSchemaUtils]
@zodart
abstract class OrderSchema {
  static final schema = (
    id: ItemSchema.schema.id, // ðŸš€ Can be reused even from other schemas
    customer: CustomerSchema.zObject,
    items: ZArray(ItemSchema.zObject),
  );

  /// Access to the generated helper class, which contains:
  ///
  /// - The `ZObject` instance for parsing/validating the schema.
  /// - A `withMapper` function for mapping parsed record to custom objects.
  /// - A `shape` descriptor containing field mappings and runtime type info.
  /// - Enum-style access to the schema properties.
  static const z = _$ZOrderSchemaUtils();

  /// Create custom mapper to [Order] class using the generated mapper.
  ///
  /// Rock-solid typesafety using the Dart record.
  static ZObject<Order> get zObject => z.withMapper(
    (order) => Order(
      id: order.id,
      customer: order.customer,
      items: order.items,
    ),
  );
}

void main() {
  // Parses into `ZRes<Order>`.
  final res = OrderSchema.zObject.parse({
    'id': '-1', // Invalid id
    'customer': {
      'id': '2413',
      'firstName': 'Zod',
      'lastName': 'Ard',
    },
    'items': [
      {
        'id': '1',
        'name': 'cookie',
        'price': -1.0, // Invalid price
      },
      {
        'id': '2',
        'name': 'coffee',
        'price': 129.0,
      },
    ],
  });

  if (res.isSuccess) {
    print(res.value);
  } else {
    print('ðŸ”´ Validation failed!');
    print(res.issueSummary);
    print('Order ID issue: ${res.getRawIssuesFor(OrderSchema.z.props.id.name)?.localizedSummary}');
  }
}
